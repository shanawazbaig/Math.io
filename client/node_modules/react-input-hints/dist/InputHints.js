(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.InputHints = f()}})(function(){var define,module,exports;module={exports:(exports={})};
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var React = require('react');
var Component = React.Component;

var PropTypes = require('prop-types');

var TICK_INIT = 'TICK_INIT';
var TICK_WRITE = 'TICK_WRITE';
var TICK_DELETE = 'TICK_DELETE';
var START_DELETE = 'START_DELETE';

function getInputProps(_ref) {
    var inputProps = _objectWithoutProperties(_ref, []);

    delete inputProps.placeholders;
    delete inputProps.waitBeforeDeleteMs;
    delete inputProps.writeSpeedMs;
    delete inputProps.deleteSpeedMs;
    delete inputProps.placeholder;
    return inputProps;
}

var InputHints = function (_Component) {
    _inherits(InputHints, _Component);

    function InputHints(props) {
        _classCallCheck(this, InputHints);

        var _this = _possibleConstructorReturn(this, (InputHints.__proto__ || Object.getPrototypeOf(InputHints)).call(this, props));

        _this.tick = _this.tick.bind(_this);
        _this.state = {
            currentPlaceholderIdx: 0,
            currentCharPos: 0,
            isDeleting: false,
            inputProps: getInputProps(props)
        };
        return _this;
    }

    _createClass(InputHints, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.queueTick(TICK_INIT);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            clearTimeout(this.ticker);
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            this.setState({
                inputProps: getInputProps(nextProps)
            });
        }
    }, {
        key: 'randomizeTimeout',
        value: function randomizeTimeout(ms) {
            // TODO: probably should implement a minimum timeout
            return Math.random() * ms;
        }
    }, {
        key: 'queueTick',
        value: function queueTick(type) {
            var _props = this.props,
                writeSpeedMs = _props.writeSpeedMs,
                deleteSpeedMs = _props.deleteSpeedMs,
                waitBeforeDeleteMs = _props.waitBeforeDeleteMs;


            var timeout = type === TICK_INIT ? 0 : type === TICK_WRITE ? this.randomizeTimeout(writeSpeedMs) : type === TICK_DELETE ? this.randomizeTimeout(deleteSpeedMs) : type === START_DELETE ? waitBeforeDeleteMs : 0; // ¯\_(ツ)_/¯

            this.ticker = setTimeout(this.tick, timeout);
        }
    }, {
        key: 'moveToNextPlaceholder',
        value: function moveToNextPlaceholder() {
            var placeholders = this.props.placeholders;
            var currentPlaceholderIdx = this.state.currentPlaceholderIdx;

            var nextPlaceholderIdx = currentPlaceholderIdx + 1;
            this.setState({
                isDeleting: false,
                currentPlaceholderIdx: nextPlaceholderIdx < placeholders.length ? nextPlaceholderIdx : 0,
                currentCharPos: 0
            });
        }
    }, {
        key: '_getTextInputNode',
        value: function _getTextInputNode() {
            return this.refTextInput;
        }
    }, {
        key: 'tick',
        value: function tick() {
            var placeholders = this.props.placeholders;
            var _state = this.state,
                currentPlaceholderIdx = _state.currentPlaceholderIdx,
                currentCharPos = _state.currentCharPos,
                isDeleting = _state.isDeleting;


            var currentPlaceholder = placeholders[currentPlaceholderIdx];

            var nextCharPos = isDeleting ? currentCharPos - 1 : currentCharPos + 1;

            if (isDeleting) {
                if (nextCharPos < 0) {
                    this.moveToNextPlaceholder();
                } else {
                    this.setState({
                        currentCharPos: nextCharPos
                    });
                }
                this.queueTick(TICK_DELETE);
            } else {
                if (nextCharPos > currentPlaceholder.length) {
                    this.setState({
                        isDeleting: true
                    });
                    this.queueTick(START_DELETE);
                } else {
                    this.setState({
                        currentCharPos: nextCharPos
                    });
                    this.queueTick(TICK_WRITE);
                }
            }
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var placeholders = this.props.placeholders;
            var _state2 = this.state,
                currentPlaceholderIdx = _state2.currentPlaceholderIdx,
                currentCharPos = _state2.currentCharPos,
                inputProps = _state2.inputProps;


            var currentPlaceholder = placeholders[currentPlaceholderIdx];
            var placeholder = currentPlaceholder.slice(0, currentCharPos);

            return React.createElement('input', _extends({ ref: function ref(e) {
                    return _this2.refTextInput = e;
                }, placeholder: placeholder }, inputProps));
        }
    }]);

    return InputHints;
}(Component);

InputHints.propTypes = {
    placeholders: PropTypes.array.isRequired,
    waitBeforeDeleteMs: PropTypes.number,
    writeSpeedMs: PropTypes.number,
    deleteSpeedMs: PropTypes.number
};
InputHints.defaultProps = {
    waitBeforeDeleteMs: 2000,
    writeSpeedMs: 100,
    deleteSpeedMs: 60
};


function inputWrapper(WrappedComponent) {
    var Input = function (_Component2) {
        _inherits(Input, _Component2);

        function Input() {
            _classCallCheck(this, Input);

            return _possibleConstructorReturn(this, (Input.__proto__ || Object.getPrototypeOf(Input)).apply(this, arguments));
        }

        _createClass(Input, [{
            key: 'focus',

            /* eslint-disable brace-style */
            value: function focus() {
                this.c._getTextInputNode().focus();
            }
        }, {
            key: 'blur',
            value: function blur() {
                this.c._getTextInputNode().blur();
            }
            /* eslint-enable brace-style */

        }, {
            key: 'render',
            value: function render() {
                var _this4 = this;

                return React.createElement(WrappedComponent, _extends({}, this.props, { ref: function ref(c) {
                        return _this4.c = c;
                    } }));
            }
        }]);

        return Input;
    }(Component);

    Input.displayName = WrappedComponent.displayName || 'Component';
    return Input;
}

module.exports = inputWrapper(InputHints);


return module.exports;});
